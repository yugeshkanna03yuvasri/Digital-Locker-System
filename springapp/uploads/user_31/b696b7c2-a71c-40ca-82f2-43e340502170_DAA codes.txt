BUBBLE SORT:

#include <iostream>
using namespace std;
int main() 
{
   int n;
   cin>>n;
   int arr[n];
   
   for(int i=0;i<n;i++)
   {
       cin>>arr[i];
   }
   
   for(int i=1;i<n;i++)  //iteration
   {
       int flag = 0;
       for(int j=0;j<n-i;j++)  //index-->j
       {
           if(arr[j] > arr[j+1])
           {
               flag = 1;
               arr[j] = (arr[j] + arr[j+1]) - (arr[j+1] = arr[j]);
            //   int temp = arr[j];
            //   arr[j] = arr[j+1];
            //   arr[j+1] = temp;
           }
       }
       if(flag == 0)  break;
   }
   
   for(int i=0;i<n;i++)
   {
       cout<<arr[i]<<" ";
   }
}

SELECTION SORT:

#include <iostream>
using namespace std;
int main() 
{
   int n;
   cin>>n;
   int arr[n];
   
   for(int i=0;i<n;cin>>arr[i++]);
   
   for(int i=0;i<n;i++) //index
   {
       int min = i;
       for(int j=i+1;j<n;j++) //iteration
       {
           if(arr[min] > arr[j])
               min = j;
       }
       int temp = arr[i];
       arr[i] = arr[min];
       arr[min] = temp;
   }
   
   for(int i=0;i<n;cout<<arr[i++]<<" ");
}

INSERTION SORT:

#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int arr[n];
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    int temp;
    for(int i=1;i<n;i++)  //index
    {
        for(int itr=i;itr>0;itr--)  //iterations in reverse
        {
            if(arr[itr] < arr[itr-1])
            {
                temp=arr[itr];
                arr[itr]=arr[itr-1];
                arr[itr-1]=temp;
                
            }
            else
            {
                break;
            }
        }
    }
     
    for(int i=0;i<n;i++)
    {
        cout<<arr[i]<<" ";
    }
    
}

MERGE SORT:

#include <iostream>
using namespace std;
int* Sort(int* leftarr,int* rightarr,int s1,int s2)
{
   int* joined = new int[s1+s2];
   int i = 0,j = 0,k = 0; //i->left , j->right , k->joined
   while(i<s1 && j<s2)
   {
       if(leftarr[i] < rightarr[j])
       {
         joined[k++] = leftarr[i++];
       }
       else
       {
         joined[k++] = rightarr[j++];
       }
   }
   
   while(i<s1)
   {
       joined[k++] = leftarr[i++];
   }
   while(j<s2)
   {
       joined[k++] = rightarr[j++];
   }
   return joined;
}

int* merge(int *arr,int size)
{
    if(size==1) return arr;
    int mid = size/2;
    int *leftarr = new int[mid];
    int *rightarr = new int[size-mid];
    for(int ind=0;ind<mid;ind++)
    {
        leftarr[ind] = arr[ind];
    }
    
    int itr = 0;
    for(int ind=mid;ind<size;ind++)
    {
        rightarr[itr++] = arr[ind];
    }
    leftarr = merge(leftarr,mid);
    rightarr = merge(rightarr,size-mid);
    return Sort(leftarr,rightarr,mid,size-mid);
}

int main() {
    int size;
    cin>>size;
    int *arr = new int[size];
    for(int i=0;i<size;cin>>arr[i++]);
    int* res = merge(arr,size);
    for(int i=0;i<size;i++)
    {
        cout<<res[i]<<" ";
    }
    return 0;
}

QUICK SORT:

#include<iostream>
using namespace std;

void quickSort(int arr[],int low,int high)
{
    if(low>=high) return;
    int mid = (low+high)/2;
    int pivot = arr[mid];
    int first = low;
    int last = high;
    while(first <= last)
    {
        while(pivot > arr[first])
            first++;
        while(pivot < arr[last])
            last--;
       if(first<=last)
       { 
           int temp = arr[first];
           arr[first] = arr[last];
           arr[last] = temp;
           first++;
           last--;
       }
    }
    quickSort(arr,low,last);
    quickSort(arr,first,high);
}

int main()
{
    int size,ind;
    cin>>size;
    int arr[size];
    for(ind=0;ind<size;cin>>arr[ind++]);
    quickSort(arr,0,size-1);
    for(ind=0;ind<size;ind++)
    {
        cout << arr[ind] << " ";
    }
    return 0;
}

_______________________________________________________________________________________

SEARCHING ALGORITHMS:

1.BINARY SEARCH:

#include<iostream>
using namespace std;

int main()
{
    int size,ind,target;
    cin>>size;
    int arr[size];
    for(ind=0;ind<size;cin>>arr[ind++]);
    cin>>target;
    
    int low = 0;
    int high = size-1;
    while(low <= high)
    {
        int mid = (low+high)/2;
        if(arr[mid] == target)
        {
            cout << "Found";
            return 0;
        }
        else if(arr[mid] < target)
            low = mid+1;
        else if(arr[mid] > target)
            high = mid-1;
    }
    cout << "Not Found";
}

________________________________________________________________________________________

HEAP:

1.MINHEAP:

#include <iostream>
#include <vector>
using namespace std;
class MinHeap
{
    public:
    vector<int> arr;
    void heapifyUp(int ind)
    {
        int parentInd = (ind-1)/2;
        while(ind > 0 && arr[parentInd] > arr[ind])
        {
            int temp = arr[parentInd];
            arr[parentInd] = arr[ind];
            arr[ind] = temp;
            ind = parentInd;
            parentInd = (ind-1)/2;
        }
    }
    
    void create(int num)
    {
        arr.push_back(num);
        heapifyUp(arr.size()-1);
    }
    
    void display()
    {
        for(int val : arr)
        {
            cout<<val<<" ";
        }
    }
};

int main() 
{
    MinHeap heap;
    int N,num,itr;
    cin>>N;
    
    for(itr=1;itr<=N;itr++)
    {
        cin>>num;
        heap.create(num);
    }
    
    heap.display();
    
}


HEAPSORT(MINHEAP):

#include <iostream>
#include <vector>
using namespace std;
class MinHeap
{
    public:
    vector<int> arr;
    
    void heapifyDown(int ind)
    {
        int left = (2*ind + 1);
        int right = (2*ind + 2);
        int small = ind;
        
        if(left < arr.size() && arr[small] > arr[left])
           small = left;
        
        if(right < arr.size() && arr[small] > arr[right])
           small = right;
           
         if(small != ind)
         {
             int temp = arr[ind];
             arr[ind] = arr[small];
             arr[small] = temp;
             heapifyDown(small);
         }
    }
    
    void display()
    {
        while(arr.size() != 0)
        {
            cout<<arr[0]<<" ";
            arr[0] = arr.back();
            arr.pop_back();
            heapifyDown(0);
        }
    }
    
    void create(int num)
    {
        arr.push_back(num);
        heapifyDown(arr.size()-1);
    }
};

int main() 
{
    MinHeap heap;
    int N,num,itr;
    cin>>N;
    
    for(itr=1;itr<=N;itr++)
    {
        cin>>num;
        heap.create(num);
    }
    
    heap.display();
    
}
________________________________________________________________________________________

GREEDY ALGORITHM:

1.ACTIVITY SELECTION:

#include <iostream>
using namespace std;
int main(){
   int size;
    cin >> size;
    int start[size];
    int end[size];
    for(int ind=0;ind<size;ind++)
    {
        cin >> start[ind];
        cin >> end[ind];
    }
    for(int ind=1;ind<size;ind++)
    {
        for(int itr=0;itr<size-ind;itr++){
            if(end[itr] > end[itr+1])
            {
                int temp1=end[itr];
                end[itr] = end[itr+1];
                end[itr+1] = temp1;
                
                int temp2= start[itr];
                start[itr]= start[itr+1];
                start[itr+1] = temp2;
            }
        }
    }
    int count=1;
    int prevtime = end[0];
    for(int ind=1;ind<size;ind++){
        if(start[ind] >= prevtime){
            count++;
            prevtime = end[ind];
        }
    }
    cout << count;
}
    
   
2.FRACTIONAL KNAPSACK

#include <iostream>
#include <iomanip>
using namespace std;
int main() 
{
   int n,amt;
   cin>>n>>amt;
   
   int pft[n];
   int wgt[n];
   
   for(int i=0;i<n;i++)
   {
       cin>>wgt[i]>>pft[i];
   }
   
   for(int i=0;i<n;i++)  //Sorting one rupee profit in desc order
   {
       for(int j=1;j<n-i;j++)
       {
           if(pft[i]/wgt[i] < pft[i+1]/wgt[i+1])
           {
               int temp = pft[i];
               pft[i] = pft[i+1];
               pft[i+1] = temp;
               
               temp = wgt[i];
               wgt[i] = wgt[i+1];
               wgt[i+1] = temp;
           }
       }
   }
   
   double sum = 0.0;
   for(int i=0;i<n;i++)
   {
       if(amt >= wgt[i])
       {
           sum += pft[i];
           amt -= wgt[i];
       }
       else
       {
           sum += (amt * (pft[i] / wgt[i]));
           break;
       }
   }
   
   cout<<fixed<<setprecision(2)<<sum;
}
________________________________________________________________________________________

STRING ALGORITHMS:

1.NAIVE ALGORITHM:

#include<iostream>
using namespace std;
int main() 
{
   string txt,ptn,str = "!@#$%^&*()";
   cin>>txt>>ptn;
   
   int l1,l2,j;
   l1 = txt.length();
   
   for(l2=0;ptn[l2];l2++);
   if(txt.find_first_of(str) != string::npos)
   {
       cout<<"Invalid input";
       return 0;
   }
   
   for(int i=0;i<=l1-l2;i++)
   {
       for(j=0;j<l2;j++)
       {
           if(txt[i+j] != ptn[j])
              break;
       }
       if(j == l2)
          cout<<i<<endl;
   }
}

2.KMP ALGORITHM:

#include <iostream>
#include <vector>
using namespace std;
vector<int> LPS(string ptn)
{
    int n = ptn.length();
    vector<int> lps(n, 0);
    int i = 1,j = 0;
    
    while(i<n)
    {
        if(ptn[j] == ptn[i])
        {
           j++;
           lps[i++] = j;
        }
        else
        {
           if(j != 0)
              j = lps[j-1];
           else
              lps[i++] = 0;
        }
    }
    return lps;
}

int KMP(string txt,string ptn)
{
    vector<int> lps = LPS(ptn);
    int m,n,i,j;
    m = txt.length();
    n = ptn.length();
    i = 0,j = 0;
   
    while(i < m)
    {
        if(ptn[j] == txt[i])
        {
            i++;
            j++;
        }
        if(j == n)
        {
            cout<<(i - j);
            j = lps[j-1];
            return 1;
        }
        else if(ptn[j] != txt[i])
        {
            if(j != 0)
               j = lps[j-1];
            else
               i++;
        }
    }
    return 0;
}

int main() 
{
    string txt,ptn;
    cin>>txt>>ptn;
    if(KMP(txt,ptn) == 0)
        cout<<"No match found";
}

3.ROBIN KARP ALGORITHM:

#include <iostream>
using namespace std;

string func(string& str,int l,int r)
{
    while(l>=0 && r<str.length() && str[l]==str[r])
    {
        l--;
        r++;
    }
    return str.substr(l+1, r-l-1);
}

int main() 
{
    string str,res = "";
    cin>>str;
    
    for(int i=0;i<str.length();i++)
    {
        string odd = func(str,i,i);
        string even = func(str,i,i+1);
        
        if(res.length() < odd.length())
           res = odd;
        if(res.length() < even.length())
           res = even;
    }
    cout<<res;
}